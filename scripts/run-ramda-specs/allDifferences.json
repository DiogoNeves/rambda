{
  "adjust": {
    "count": 1,
    "reason": "ramda method accepts an array-like object"
  },
  "allPass": {
    "count": 1,
    "reason": "ramda method returns a curried function whose arity matches that of the highest-arity predicate"
  },
  "anyPass": {
    "count": 1,
    "reason": "ramda method returns a curried function whose arity matches that of the highest-arity predicate"
  },
  "isEmpty": {
    "count": 1,
    "reason": "ramda method supports typed arrays"
  },
  "both": {
    "count": 1,
    "reason": "ramda library supports fantasy-land"
  },
  "chain": {
    "count": 5,
    "reason": "ramda method passes to `chain` property if available | ramda library supports fantasy-land"
  },
  "either": {
    "count": 1,
    "reason": "ramda library supports fantasy-land"
  },
  "complement": {
    "count": 1,
    "reason": "ramda library supports fantasy-land"
  },
  "difference": {
    "count": 1,
    "reason": "ramda method supports negative zero"
  },
  "compose": {
    "count": 3,
    "reason": "ramda method passes context to functions | rambda composed functions have no length"
  },
  "pipe": {
    "count": 3,
    "reason": "ramda method passes context to functions | rambda composed functions have no length"
  },
  "curry": {
    "count": 3,
    "reason": "ramda library support placeholder(R.__)"
  },
  "concat": {
    "count": 1,
    "reason": "ramda method pass to `concat` property if present"
  },
  "cond": {
    "count": 2,
    "reason": "pass to transformer is not applied in rambda method"
  },
  "dropLast": {
    "count": 5,
    "reason": "ramda method can act as a transducer"
  },
  "clone": {
    "count": 9,
    "reason": "rambda method work only with objects and arrays"
  },
  "endsWith": {
    "count": 4,
    "reason": "rambda method doesn't support arrays"
  },
  "equals": {
    "count": 14,
    "reason": "rambda method doesn't support recursive data structures, objects with same enumerable properties, map/weakmap type of variables | ramda dispatches to `equals` method recursively"
  },
  "filter": {
    "count": 1,
    "reason": "ramda method dispatches to `filter` method of object"
  },
  "flip": {
    "count": 4,
    "reason": "ramda.flip returns a curried function | rambda.flip work only for functions with arity below 5"
  },
  "forEach": {
    "count": 1,
    "reason": "ramda method dispatches to `forEach` method"
  },
  "groupBy": {
    "count": 1,
    "reason": "ramda method support transforms"
  },
  "groupWith": {
    "count": 2,
    "reason": "ramda method support string"
  },
  "has": {
    "count": 1,
    "reason": "rambda method does check properties from the prototype chain"
  },
  "ifElse": {
    "count": 2,
    "reason": "rambda method doesn't return a curried function"
  },
  "includes": {
    "count": 1,
    "reason": "ramda method pass to `equals` method if available"
  },
  "indexBy": {
    "count": 1,
    "reason": "ramda method can act as a transducer"
  },
  "reduce": {
    "count": 2,
    "reason": "rambda library doesn't have `R.reduced` method | ramda method pass to `reduce` method"
  },
  "reject": {
    "count": 1,
    "reason": "ramda method dispatches to `filter` method"
  },
  "indexOf": {
    "count": 2,
    "reason": "ramda method dispatches to `indexOf` method"
  },
  "lastIndexOf": {
    "count": 3,
    "reason": "ramda method dispatches to `lastIndexOf` method"
  },
  "length": {
    "count": 1,
    "reason": "ramda method supports object with `length` method"
  },
  "keys": {
    "count": 1,
    "reason": "ramda method works for primitives"
  },
  "partition": {
    "count": 1,
    "reason": "ramda library supports fantasy-land"
  },
  "path": {
    "count": 1,
    "reason": "ramda method supports negative indexes"
  },
  "pathEq": {
    "count": 1,
    "reason": "ramda library supports fantasy-land"
  },
  "paths": {
    "count": 1,
    "reason": "ramda method supports negative indexes"
  },
  "pluck": {
    "count": 1,
    "reason": "ramda method behaves as a transducer"
  },
  "propEq": {
    "count": 1,
    "reason": "ramda method pass to `equals` method if available"
  },
  "sortBy": {
    "count": 1,
    "reason":"ramda method works with array-like objects"
  },
  "take": {
    "count": 3,
    "reason":"rambda library doesn't have 'R.into` method"
  },
  "tap": {
    "count": 2,
    "reason":"ramda method can act as a transducer"
  },
  "trim": {
    "count": 1,
    "reason":"ramda method trims all ES5 whitespace"
  },
  "tryCatch": {
    "count": 1,
    "reason":"ramda method returns a function with the same arity"
  },
  "type": {
    "count": 1,
    "reason": "ramda method returns 'Number' type to NaN input, while rambda method returns 'NaN'"
  },
  "unless": {
    "count": 4,
    "reason": "rambda library doesn't have `R.of`"
  },
  "uniq": {
    "count": 2,
    "reason": "ramda method pass to `uniq` method | ramda method uses reference equality for functions"
  },
  "update": {
    "count": 1,
    "reason": "ramda method accepts an array-like object"
  },
  "without": {
    "count": 2,
    "reason": "ramda method act as a transducer | ramda method pass to `equals` method"
  },
  "startsWith": {
    "count": 4,
    "reason": "rambda method doesn't support arrays"
  },
  "xor": {
    "count": 1,
    "reason": "ramda method support empty call of method"
  }
}